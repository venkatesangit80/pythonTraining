from typing import TypedDict, List, Dict, Optional

class AgentState(TypedDict):
    prompt: str
    history: List[Dict[str, str]]
    agent_plan: List[Dict]
    current_step: int
    logs: List[str]
    response: Optional[str]
    responses: List[str]
    executed_agents: List[str]
    meta: Dict[str, List[str]]  # maps independent agents to dependent agents
    results: Dict[str, str]     # maps agent name to its execution output



import google.generativeai as genai
import os
import json
from typing import List, Dict, Tuple

# Initialize Gemini model
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
genai.configure(api_key=GOOGLE_API_KEY)
model = genai.GenerativeModel("gemini-1.5-flash")

# Descriptions used in prompt planning
AGENT_DESCRIPTIONS = {
    "health": "Check over and under utilized servers.",
    "forecast": "Predict resource usage trends.",
    "recommendation": "Recommend actions based on current and future health."
}

def generate_agent_plan(user_prompt: str, history: List[Dict]) -> Tuple[List[Dict], Dict[str, List[str]], Dict[str, str]]:
    """
    Use Gemini to generate a structured plan of agents to run based on prompt and conversation history.
    Returns the plan, meta mapping, and initial empty results dict.
    """
    history_text = "\n".join([f"{m['role']}: {m['content']}" for m in history])

    system_prompt = f"""
You are an agent planner.

Your task is to determine the next set of agents to execute based on the full conversation context â€” not just the latest user input.

Review any agent responses or summaries:

The available agents and their purposes are:
{json.dumps(AGENT_DESCRIPTIONS, indent=2)}

Return a Python dictionary with the following keys:
- "plan": a list of agent contracts. Each contract should include:
    - agent name
    - description (from above)
    - input_value (e.g., 'APP1' or previous agent name if dependent)
    - input_instruction
    - output_instruction
    - action_type: 'independent' or 'dependent'
- "meta": a dictionary mapping each independent agent to its dependent agents
- "results": a dictionary pre-populated with independent agent keys and empty string values

If the user's input is a greeting, thanks, or unrelated to monitoring, return:
{{ "plan": [], "meta": {{}}, "results": {{}} }}

Respond ONLY with a Python dictionary in the specified format.

Example:
{{
  "plan": [
    {{
      "agent": "health",
      "description": "Check over and under utilized servers.",
      "input_value": "APP1",
      "input_instruction": "Analyze server load",
      "output_instruction": "Return list of high-CPU servers",
      "action_type": "independent"
    }},
    {{
      "agent": "forecast",
      "description": "Predict resource usage trends.",
      "input_value": "health",
      "input_instruction": "Use health output to forecast future spikes",
      "output_instruction": "Return predicted CPU usage",
      "action_type": "dependent"
    }}
  ],
  "meta": {{
    "health": ["forecast"]
  }},
  "results": {{
    "health": ""
  }}
}}
"""

    prompt = f"{system_prompt}\n\nConversation so far:\n{history_text}\n\nUser query: \"{user_prompt}\"\n"
    response = model.generate_content(prompt)
    try:
        parsed = json.loads(response.text)
        return parsed["plan"], parsed.get("meta", {}), parsed.get("results", {})
    except Exception as e:
        raise ValueError(f"Failed to parse agent planning output: {e}\nRaw response: {response.text}")





You are a precise information extractor.

Given a user query, extract the names of all mentioned servers. Return the list of server names as a valid Python list of strings.

Only include items that follow typical server naming patterns like 'srv1', 'server03', 'db-node1', etc.

Do NOT include explanations or extra text. Return only the list.

Example:
Input: "Check the health of servers srv1, srv2, and srv3."
Output: ["srv1", "srv2", "srv3"]

Input: "Get metrics for db-node1 and api-node2."
Output: ["db-node1", "api-node2"]

Input: "How is the system doing?"
Output: []

User input: "{user_prompt}"